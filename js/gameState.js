// gameState.js - Game State Management

import { CONFIG } from './config.js';
import { randomFloat, randomChoice, saveToStorage, loadFromStorage, removeFromStorage, deepClone } from './utils.js';

// Game state object
export const gameState = {
    // Current game status
    currentWeek: 1,
    currentDay: 1,

    // Team stats
    team: {
        name: CONFIG.PLAYER_TEAM.name,
        stats: {
            pass: 5,
            dribble: 5,
            shoot: 5
        },
        restBonus: false,
        restPenaltyPending: false,
        aces: [],
        gearSecond: [], // Players who awakened to Gear Second (2.0x multiplier)
        weeklyTraining: [] // Track training this week for total training calculation
    },

    // Captain system
    captain: {
        personality: "熱血",
        policy: "論理的",
        name: null  // For special captains like "すぅぅぅぅてぇ"
    },

    // Tournament data
    tournament: {
        bracket: [],
        currentRound: 1,
        playerTeamId: null,
        results: []
    },

    // Current match data (temporary)
    currentMatch: null,

    // Game completed flag
    gameCompleted: false,
    championshipWon: false,

    // Last used tactics (for default in next match)
    lastTactics: [],

    // Saved tactics presets (unlimited)
    tacticsPresets: [],

    // P70: アクション履歴（最新5件を保持）- バグ報告用
    actionHistory: [],

    // Position abilities (PowerPro style) - 弱点/強みシステム
    abilities: {
        // 練習カウンター（弱点克服/強み獲得の進捗）
        trainingProgress: {
            judgment: 0,   // 判断系カウンター
            movement: 0,   // 動作系カウンター
            shooting: 0,   // シュート系カウンター
            general: 0     // 汎用カウンター
        },
        // 克服した弱点のIDリスト
        overcomeWeaknesses: [],
        // 獲得した強みのIDリスト
        acquiredStrengths: [],
        // 勘違いが改善されたカテゴリのリスト (P64: カテゴリ完了時に一括改善)
        correctedCategories: [],
        // 最後に変化があった情報（通知用）
        lastChange: null
    }
};

// Initialize new game with random captain and stats
export function initializeNewGame() {
    // 2% chance for special captain "すぅぅぅぅてぇ"
    const isSuteee = Math.random() < 0.02;

    if (isSuteee) {
        // キャプテンすぅぅぅぅてぇ
        gameState.captain.personality = "アンポンタン";
        gameState.captain.policy = "トンチンカン";
        gameState.captain.name = "すぅぅぅぅてぇ";
    } else {
        // Random captain personality (excluding アンポンタン)
        const personalities = Object.keys(CONFIG.CAPTAIN.PERSONALITY).filter(p => p !== "アンポンタン");
        gameState.captain.personality = randomChoice(personalities);

        // Random captain policy (excluding トンチンカン)
        const policies = Object.keys(CONFIG.CAPTAIN.POLICY).filter(p => p !== "トンチンカン");
        gameState.captain.policy = randomChoice(policies);
        gameState.captain.name = null;
    }

    // Random initial stats
    gameState.team.stats.pass = randomFloat(CONFIG.INITIAL.MIN, CONFIG.INITIAL.MAX, 1);
    gameState.team.stats.dribble = randomFloat(CONFIG.INITIAL.MIN, CONFIG.INITIAL.MAX, 1);
    gameState.team.stats.shoot = randomFloat(CONFIG.INITIAL.MIN, CONFIG.INITIAL.MAX, 1);

    // Reset other values
    gameState.currentWeek = 1;
    gameState.currentDay = 1;
    gameState.team.restBonus = false;
    gameState.team.restPenaltyPending = false;
    gameState.team.aces = [];
    gameState.team.gearSecond = [];
    gameState.team.weeklyTraining = [];
    gameState.tournament.currentRound = 1;
    gameState.tournament.results = [];
    gameState.currentMatch = null;
    gameState.gameCompleted = false;
    gameState.championshipWon = false;
    gameState.lastTactics = [];

    // Initialize abilities (all weaknesses active, no strengths)
    gameState.abilities = {
        trainingProgress: {
            judgment: 0,
            movement: 0,
            shooting: 0,
            general: 0
        },
        overcomeWeaknesses: [],
        acquiredStrengths: [],
        correctedCategories: [],
        lastChange: null
    };

    // Tournament bracket will be generated by tournament.js

    return gameState;
}

// Save game to localStorage
export function saveGame() {
    const success = saveToStorage(CONFIG.GAME.STORAGE_KEY, gameState);
    return success;
}

// Load game from localStorage
export function loadGame() {
    const data = loadFromStorage(CONFIG.GAME.STORAGE_KEY);
    if (data && validateGameState(data)) {
        Object.assign(gameState, data);
        return true;
    }
    return false;
}

// Check if save exists
export function hasSaveData() {
    return loadFromStorage(CONFIG.GAME.STORAGE_KEY) !== null;
}

// Reset game (clear localStorage)
export function resetGame() {
    removeFromStorage(CONFIG.GAME.STORAGE_KEY);
    initializeNewGame();
}

// Validate game state structure
function validateGameState(data) {
    try {
        // Check required fields
        if (!data.currentWeek || !data.currentDay) return false;
        if (!data.team || !data.team.stats) return false;
        if (!data.team.stats.pass || !data.team.stats.dribble || !data.team.stats.shoot) return false;
        if (!data.captain || !data.captain.personality || !data.captain.policy) return false;
        if (!data.tournament) return false;

        // Check valid ranges
        if (data.currentWeek < 1 || data.currentWeek > CONFIG.GAME.TOTAL_WEEKS) return false;
        if (data.currentDay < 1 || data.currentDay > 7) return false;

        return true;
    } catch (e) {
        console.error('Game state validation failed:', e);
        return false;
    }
}

// Advance to next day
export function advanceDay() {
    // Apply rest penalty if pending
    if (gameState.team.restPenaltyPending) {
        const penalty = CONFIG.TRAINING["休養"].penalty.all;
        gameState.team.stats.pass = Math.max(1, gameState.team.stats.pass - penalty);
        gameState.team.stats.dribble = Math.max(1, gameState.team.stats.dribble - penalty);
        gameState.team.stats.shoot = Math.max(1, gameState.team.stats.shoot - penalty);
        gameState.team.restPenaltyPending = false;
    }

    gameState.currentDay++;

    // Check if week ended
    if (gameState.currentDay > 7) {
        advanceWeek();
    }

    // Auto-save if enabled
    if (CONFIG.GAME.AUTO_SAVE) {
        saveGame();
    }
}

// Advance to next week
function advanceWeek() {
    gameState.currentWeek++;
    gameState.currentDay = 1;

    // Clear rest bonus at start of new week
    gameState.team.restBonus = false;

    // Clear weekly training tracking
    gameState.team.weeklyTraining = [];

    // Check if game completed
    if (gameState.currentWeek > CONFIG.GAME.TOTAL_WEEKS) {
        gameState.gameCompleted = true;
    }
}

// Get current day info
export function getCurrentDayInfo() {
    return CONFIG.WEEK_SCHEDULE[gameState.currentDay];
}

// Calculate total training effect based on weekly training
function calculateTotalTrainingEffect() {
    // Find the highest single training value across all weekly training
    let maxValue = 0;

    if (gameState.team.weeklyTraining.length > 0) {
        // Use actual weekly training data
        gameState.team.weeklyTraining.forEach(training => {
            const values = Object.values(training);
            const max = Math.max(...values);
            if (max > maxValue) {
                maxValue = max;
            }
        });
    } else {
        // No training this week - calculate potential max from available trainings
        const trainings = ['パス練習', 'ドリブル練習', 'シュート練習'];
        trainings.forEach(trainingName => {
            const menu = CONFIG.TRAINING[trainingName];
            if (menu && menu.effect) {
                const growth = calculateTrainingGrowth(menu.effect);
                const values = Object.values(growth);
                const max = Math.max(...values);
                if (max > maxValue) {
                    maxValue = max;
                }
            }
        });
    }

    // If still no max value, use default base value
    if (maxValue === 0) {
        maxValue = 1.2; // Default to match shoot training
    }

    // Divide equally among 3 stats
    const baseValue = maxValue / 3;
    const equalValue = Math.floor(baseValue * 10) / 10; // Floor to 1 decimal place

    // Calculate remainder (keep precision for proper allocation)
    const totalEqual = equalValue * 3;
    const remainder = Math.round((maxValue - totalEqual) * 10) / 10;

    // Allocate remainder based on captain policy
    const policy = CONFIG.CAPTAIN.POLICY[gameState.captain.policy];
    let effect = {
        pass: equalValue,
        dribble: equalValue,
        shoot: equalValue
    };

    // Allocate ALL remainder to favored stat (no splitting)
    if (remainder > 0) {
        if (policy.focusLowest) {
            // Allocate to lowest stat
            const stats = gameState.team.stats;
            const lowestStat = Object.keys(stats).reduce((a, b) =>
                stats[a] < stats[b] ? a : b
            );
            effect[lowestStat] += remainder;
        } else if (policy.statModifier) {
            // Allocate to stat with highest modifier
            const modifiers = policy.statModifier;
            const favoredStat = Object.keys(modifiers).reduce((a, b) =>
                modifiers[a] > modifiers[b] ? a : b
            );
            effect[favoredStat] += remainder;
        } else {
            // Default: allocate to pass
            effect.pass += remainder;
        }
    }

    return effect;
}

// Apply training to team stats
export function applyTraining(menuName) {
    const menu = CONFIG.TRAINING[menuName];
    if (!menu) return false;

    // Check if training is available on current day
    const currentDayName = getCurrentDayInfo().day;
    if (!menu.available.includes(currentDayName)) {
        return false;
    }

    // Check for boycott
    if (isBoycottActive()) {
        return false;
    }

    // Handle rest bonus
    if (menuName === "休養") {
        gameState.team.restBonus = true;
        return true;
    }

    // Calculate growth with captain modifiers
    let baseEffect = menu.effect;
    let growth;

    // Special handling for Anpontan's total training
    const personality = CONFIG.CAPTAIN.PERSONALITY[gameState.captain.personality];
    if (menuName === "総合練習" && personality.specialTraining && gameState.captain.personality === "アンポンタン") {
        const currentDay = getCurrentDayInfo().day;

        if (currentDay === "金") {
            // Friday: 7.0 each stat
            growth = { pass: 7.0, dribble: 7.0, shoot: 7.0 };
        } else {
            // Mon-Thu: 0.0 each stat
            growth = { pass: 0.0, dribble: 0.0, shoot: 0.0 };
        }
    } else {
        // Normal training calculation
        // For total training, use dynamic calculation
        if (menuName === "総合練習") {
            baseEffect = calculateTotalTrainingEffect();
        }

        growth = calculateTrainingGrowth(baseEffect);
    }

    // Record this training for weekly tracking
    // 総合練習も記録して、次の総合練習計算に反映させる
    gameState.team.weeklyTraining.push(deepClone(growth));

    // Apply growth to stats
    gameState.team.stats.pass += growth.pass;
    gameState.team.stats.dribble += growth.dribble;
    gameState.team.stats.shoot += growth.shoot;

    // Round if needed (keep float for total training)
    if (!menu.allowFloat) {
        gameState.team.stats.pass = Math.round(gameState.team.stats.pass * 10) / 10;
        gameState.team.stats.dribble = Math.round(gameState.team.stats.dribble * 10) / 10;
        gameState.team.stats.shoot = Math.round(gameState.team.stats.shoot * 10) / 10;
    }

    // Process ability changes (PowerPro style)
    const abilityChange = processAbilityProgress(menuName);

    return { success: true, abilityChange };
}

// Calculate training growth with captain modifiers
function calculateTrainingGrowth(baseEffect) {
    let growth = deepClone(baseEffect);

    // Apply personality modifier
    const personalityMod = getPersonalityModifier();
    growth.pass *= personalityMod;
    growth.dribble *= personalityMod;
    growth.shoot *= personalityMod;

    // Apply policy modifier
    const policy = CONFIG.CAPTAIN.POLICY[gameState.captain.policy];

    if (policy.focusLowest) {
        // Find lowest stat
        const stats = gameState.team.stats;
        const lowestStat = Object.keys(stats).reduce((a, b) =>
            stats[a] < stats[b] ? a : b
        );
        growth[lowestStat] *= policy.multiplier;
    } else if (policy.statModifier) {
        // Apply stat-specific modifiers
        growth.pass *= policy.statModifier.pass;
        growth.dribble *= policy.statModifier.dribble;
        growth.shoot *= policy.statModifier.shoot;
    }

    return growth;
}

// Get personality modifier (check for boycott and special training)
function getPersonalityModifier() {
    const personality = CONFIG.CAPTAIN.PERSONALITY[gameState.captain.personality];

    // Check for Anpontan special training
    if (personality.specialTraining && gameState.captain.personality === "アンポンタン") {
        const currentDay = getCurrentDayInfo().day;

        if (currentDay === "金") {
            return 21; // Friday: 21x effect
        } else {
            return 0.1; // Mon-Thu: 0.1x effect
        }
    }

    // Check boycott condition
    if (personality.boycottWeek && gameState.currentWeek >= personality.boycottWeek) {
        return personality.boycottEffect;
    }

    return personality.growthMultiplier;
}

// Check if boycott is active
export function isBoycottActive() {
    const personality = CONFIG.CAPTAIN.PERSONALITY[gameState.captain.personality];
    return personality.boycottWeek && gameState.currentWeek >= personality.boycottWeek;
}

// Add ace after winning a match (excluding GK)
// If all field players are already aces, awaken to Gear Second
// Returns object with awakening info: { type: 'ace' | 'gearSecond', positionIndex: number, positionName: string }
export function addAce() {
    // GK is at position 6, so only select from positions 0-5
    const fieldPlayerPositions = [0, 1, 2, 3, 4, 5];

    // Check if all field players are already aces
    const allAces = fieldPlayerPositions.every(pos => gameState.team.aces.includes(pos));

    if (allAces) {
        // All are aces, now awaken to Gear Second
        const availableForGearSecond = fieldPlayerPositions.filter(pos =>
            !gameState.team.gearSecond.includes(pos)
        );

        if (availableForGearSecond.length > 0) {
            const randomIndex = Math.floor(Math.random() * availableForGearSecond.length);
            const newGearSecondIndex = availableForGearSecond[randomIndex];
            gameState.team.gearSecond.push(newGearSecondIndex);

            // Get position name
            const positionKeys = ['LW', 'RW', 'CB', 'LB', 'RB', 'P'];
            const positionKey = positionKeys[newGearSecondIndex];
            const positionName = CONFIG.POSITIONS[positionKey].name;

            return {
                type: 'gearSecond',
                positionIndex: newGearSecondIndex,
                positionKey: positionKey,
                positionName: positionName
            };
        }
    } else {
        // Not all are aces yet, make someone an ace
        const availablePositions = fieldPlayerPositions.filter(pos =>
            !gameState.team.aces.includes(pos)
        );

        if (availablePositions.length > 0) {
            const randomIndex = Math.floor(Math.random() * availablePositions.length);
            const newAceIndex = availablePositions[randomIndex];
            gameState.team.aces.push(newAceIndex);

            // Get position name
            const positionKeys = ['LW', 'RW', 'CB', 'LB', 'RB', 'P'];
            const positionKey = positionKeys[newAceIndex];
            const positionName = CONFIG.POSITIONS[positionKey].name;

            return {
                type: 'ace',
                positionIndex: newAceIndex,
                positionKey: positionKey,
                positionName: positionName
            };
        }
    }

    return null; // No awakening (all already Gear Second)
}

// P69: Awaken an existing Ace to Gear Second
// Used after semi-finals victory
// Returns object with awakening info or null if no eligible aces
export function awakenToGearSecond() {
    // Only aces can awaken to Gear Second
    const eligiblePositions = gameState.team.aces.filter(pos =>
        !gameState.team.gearSecond.includes(pos)
    );

    if (eligiblePositions.length > 0) {
        const randomIndex = Math.floor(Math.random() * eligiblePositions.length);
        const newGearSecondIndex = eligiblePositions[randomIndex];
        gameState.team.gearSecond.push(newGearSecondIndex);

        // Get position name
        const positionKeys = ['LW', 'RW', 'CB', 'LB', 'RB', 'P'];
        const positionKey = positionKeys[newGearSecondIndex];
        const positionName = CONFIG.POSITIONS[positionKey].name;

        return {
            type: 'gearSecond',
            positionIndex: newGearSecondIndex,
            positionKey: positionKey,
            positionName: positionName
        };
    }

    return null; // No eligible aces for Gear Second
}

// Get team stats with rest bonus applied
export function getEffectiveStats() {
    const stats = deepClone(gameState.team.stats);

    if (gameState.team.restBonus) {
        const bonus = CONFIG.TRAINING["休養"].bonus.all;
        stats.pass += bonus;
        stats.dribble += bonus;
        stats.shoot += bonus;
    }

    return stats;
}

// Clear rest bonus (after match)
export function clearRestBonus() {
    gameState.team.restBonus = false;
}

// Set current match
export function setCurrentMatch(opponent) {
    gameState.currentMatch = {
        opponent: opponent,
        playerScore: 0,
        opponentScore: 0,
        isPlaying: false,
        result: null,
        attemptsRemaining: CONFIG.GAME.MAX_ATTEMPTS,
        savedTactics: [],
        failedTacticIndex: null
    };
}

// Reset failed tactic index (call when starting fresh tactics)
export function resetFailedTacticIndex() {
    if (gameState.currentMatch) {
        gameState.currentMatch.failedTacticIndex = null;
    }
}

// Clear current match
export function clearCurrentMatch() {
    gameState.currentMatch = null;
}

// Save last used tactics (for next match default)
export function saveLastTactics(tactics) {
    gameState.lastTactics = deepClone(tactics);
    saveGame();
}

// Get last used tactics
export function getLastTactics() {
    return deepClone(gameState.lastTactics) || [];
}

// Save tactics preset
export function saveTacticsPreset(name, tactics) {
    if (!gameState.tacticsPresets) {
        gameState.tacticsPresets = [];
    }

    // Check if preset with same name exists
    const existingIndex = gameState.tacticsPresets.findIndex(p => p.name === name);
    if (existingIndex >= 0) {
        // Update existing preset
        gameState.tacticsPresets[existingIndex].tactics = deepClone(tactics);
    } else {
        // Add new preset
        gameState.tacticsPresets.push({
            name: name,
            tactics: deepClone(tactics),
            createdAt: Date.now()
        });
    }
    saveGame();
}

// Get all tactics presets
export function getTacticsPresets() {
    if (!gameState.tacticsPresets) {
        gameState.tacticsPresets = [];
    }
    return deepClone(gameState.tacticsPresets);
}

// Get tactics preset by name
export function getTacticsPreset(name) {
    if (!gameState.tacticsPresets) return null;
    const preset = gameState.tacticsPresets.find(p => p.name === name);
    return preset ? deepClone(preset.tactics) : null;
}

// Delete tactics preset
export function deleteTacticsPreset(name) {
    if (!gameState.tacticsPresets) return false;
    const index = gameState.tacticsPresets.findIndex(p => p.name === name);
    if (index >= 0) {
        gameState.tacticsPresets.splice(index, 1);
        saveGame();
        return true;
    }
    return false;
}

// Rename tactics preset
export function renameTacticsPreset(oldName, newName) {
    if (!gameState.tacticsPresets) return false;
    const preset = gameState.tacticsPresets.find(p => p.name === oldName);
    if (preset) {
        preset.name = newName;
        saveGame();
        return true;
    }
    return false;
}

// Record match result
// Returns awakening info if won: { type: 'ace' | 'gearSecond', positionName: string } or null
export function recordMatchResult(won, playerScore, opponentScore) {
    const currentRound = gameState.tournament.currentRound;
    const result = {
        week: gameState.currentWeek,
        round: currentRound,
        opponent: gameState.currentMatch.opponent.name,
        won: won,
        playerScore: playerScore,
        opponentScore: opponentScore
    };

    gameState.tournament.results.push(result);

    let awakeningInfo = [];

    // Add ace if won
    if (won) {
        // P68: 対戦相手をeliminatedとしてマーク
        const opponent = gameState.currentMatch.opponent;
        if (opponent && gameState.tournament.bracket) {
            const bracketOpponent = gameState.tournament.bracket.find(
                t => t.name === opponent.name || t.prefecture === opponent.prefecture
            );
            if (bracketOpponent) {
                bracketOpponent.eliminated = true;
            }
        }

        // P69: ラウンドごとに異なる覚醒数
        // 1回戦:1, 2回戦:1, 3回戦:2, 準々決勝:2, 準決勝:ギアセカンド
        const acesToAdd = CONFIG.ACE.INCREMENT_BY_ROUND[currentRound] || 0;

        for (let i = 0; i < acesToAdd; i++) {
            const awakening = addAce();
            if (awakening) {
                awakeningInfo.push(awakening);
            }
        }

        // P69: 準決勝勝利後（ラウンド5）にギアセカンド覚醒
        if (currentRound === 5) {
            const gearSecondCount = CONFIG.ACE.GEAR_SECOND_ON_SEMIFINAL || 2;
            for (let i = 0; i < gearSecondCount; i++) {
                const awakening = awakenToGearSecond();
                if (awakening) {
                    awakeningInfo.push(awakening);
                }
            }
        }

        gameState.tournament.currentRound++;

        // Check if championship won
        if (gameState.tournament.currentRound > 6) {
            gameState.championshipWon = true;
            gameState.gameCompleted = true;
        }
    } else {
        gameState.gameCompleted = true;
    }

    // Clear rest bonus after match and set penalty flag
    if (gameState.team.restBonus) {
        gameState.team.restPenaltyPending = true;
    }
    clearRestBonus();

    // Clear current match
    clearCurrentMatch();

    return awakeningInfo;
}

// Get game state snapshot (for debugging)
export function getStateSnapshot() {
    return deepClone(gameState);
}

// Change captain personality (for boycott resolution)
export function changeCaptainPersonality() {
    // Get all personalities except パワハラ and アンポンタン
    const availablePersonalities = Object.keys(CONFIG.CAPTAIN.PERSONALITY)
        .filter(p => p !== "パワハラ" && p !== "アンポンタン");

    // Random select new personality
    gameState.captain.personality = randomChoice(availablePersonalities);
    gameState.captain.name = null; // Clear special name

    return gameState.captain.personality;
}

// Apply boycott rest penalty (-0.3 to all stats, minimum 1.0)
export function applyBoycottRestPenalty() {
    const penalty = 0.3;
    gameState.team.stats.pass = Math.max(1.0, gameState.team.stats.pass - penalty);
    gameState.team.stats.dribble = Math.max(1.0, gameState.team.stats.dribble - penalty);
    gameState.team.stats.shoot = Math.max(1.0, gameState.team.stats.shoot - penalty);
}

// Simulate training for multiple days and return total growth
// Used by "全日" button to show expected growth
// P44: キャプテンの性格/方針、現在パラメータを考慮し、最弱パラメータ入れ替わりも反映
export function simulateAllDaysTraining(menuName, daysCount) {
    // Clone current state for simulation
    const simWeeklyTraining = deepClone(gameState.team.weeklyTraining);
    // Only clone the 3 stat values (pass, dribble, shoot)
    const simStats = {
        pass: gameState.team.stats.pass,
        dribble: gameState.team.stats.dribble,
        shoot: gameState.team.stats.shoot
    };
    let simCurrentDay = gameState.currentDay;

    const totalGrowth = { pass: 0, dribble: 0, shoot: 0 };
    const personality = CONFIG.CAPTAIN.PERSONALITY[gameState.captain.personality];
    const policy = CONFIG.CAPTAIN.POLICY[gameState.captain.policy];

    // Get personality modifier (same as getPersonalityModifier but for simulation)
    let personalityMod = personality.growthMultiplier || 1.0;
    if (personality.boycottWeek && gameState.currentWeek >= personality.boycottWeek) {
        personalityMod = personality.boycottEffect || 0;
    }

    for (let i = 0; i < daysCount; i++) {
        const menu = CONFIG.TRAINING[menuName];
        if (!menu) break;

        let growth;

        // Special handling for Anpontan's total training
        if (menuName === "総合練習" && personality.specialTraining && gameState.captain.personality === "アンポンタン") {
            const dayIndex = simCurrentDay + i;
            const dayInfo = CONFIG.WEEK_SCHEDULE[dayIndex];
            if (dayInfo && dayInfo.day === "金") {
                growth = { pass: 7.0, dribble: 7.0, shoot: 7.0 };
            } else {
                growth = { pass: 0.0, dribble: 0.0, shoot: 0.0 };
            }
        } else if (menuName === "総合練習") {
            // P44: 実際のapplyTraining/calculateTotalTrainingEffectと同じロジックを使用
            // Calculate max value with full modifiers (personality + policy)
            let maxValue = 0;
            if (simWeeklyTraining.length > 0) {
                simWeeklyTraining.forEach(training => {
                    const values = Object.values(training);
                    const max = Math.max(...values);
                    if (max > maxValue) maxValue = max;
                });
            } else {
                // Calculate potential max from focused trainings WITH policy modifier
                const trainings = ['パス練習', 'ドリブル練習', 'シュート練習'];
                trainings.forEach(trainingName => {
                    const m = CONFIG.TRAINING[trainingName];
                    if (m && m.effect) {
                        // Apply personality modifier
                        let g = {
                            pass: m.effect.pass * personalityMod,
                            dribble: m.effect.dribble * personalityMod,
                            shoot: m.effect.shoot * personalityMod
                        };
                        // Apply policy modifier (same as calculateTrainingGrowth)
                        if (policy.focusLowest) {
                            let lowestStat = 'pass';
                            let lowestValue = simStats.pass;
                            if (simStats.dribble < lowestValue) {
                                lowestStat = 'dribble';
                                lowestValue = simStats.dribble;
                            }
                            if (simStats.shoot < lowestValue) {
                                lowestStat = 'shoot';
                            }
                            g[lowestStat] *= policy.multiplier || 1.0;
                        } else if (policy.statModifier) {
                            g.pass *= policy.statModifier.pass || 1.0;
                            g.dribble *= policy.statModifier.dribble || 1.0;
                            g.shoot *= policy.statModifier.shoot || 1.0;
                        }
                        const values = Object.values(g);
                        const max = Math.max(...values);
                        if (max > maxValue) maxValue = max;
                    }
                });
            }
            if (maxValue === 0) maxValue = 1.2;

            // Divide equally among 3 stats
            const baseValue = maxValue / 3;
            const equalValue = Math.floor(baseValue * 10) / 10;
            const totalEqual = equalValue * 3;
            const remainder = Math.round((maxValue - totalEqual) * 10) / 10;

            // Base effect before policy modifier
            let baseEffect = { pass: equalValue, dribble: equalValue, shoot: equalValue };

            // Allocate remainder based on policy
            if (remainder > 0) {
                if (policy.focusLowest) {
                    let lowestStat = 'pass';
                    let lowestValue = simStats.pass;
                    if (simStats.dribble < lowestValue) {
                        lowestStat = 'dribble';
                        lowestValue = simStats.dribble;
                    }
                    if (simStats.shoot < lowestValue) {
                        lowestStat = 'shoot';
                    }
                    baseEffect[lowestStat] += remainder;
                } else if (policy.statModifier) {
                    const modifiers = policy.statModifier;
                    const favoredStat = Object.keys(modifiers).reduce((a, b) =>
                        modifiers[a] > modifiers[b] ? a : b
                    );
                    baseEffect[favoredStat] += remainder;
                }
            }

            // P44: Apply personality and policy modifiers to the total training effect
            // (Same as calculateTrainingGrowth does for actual training)
            growth = {
                pass: baseEffect.pass * personalityMod,
                dribble: baseEffect.dribble * personalityMod,
                shoot: baseEffect.shoot * personalityMod
            };

            // Apply policy modifier
            if (policy.focusLowest) {
                let lowestStat = 'pass';
                let lowestValue = simStats.pass;
                if (simStats.dribble < lowestValue) {
                    lowestStat = 'dribble';
                    lowestValue = simStats.dribble;
                }
                if (simStats.shoot < lowestValue) {
                    lowestStat = 'shoot';
                }
                growth[lowestStat] *= policy.multiplier || 1.0;
            } else if (policy.statModifier) {
                growth.pass *= policy.statModifier.pass || 1.0;
                growth.dribble *= policy.statModifier.dribble || 1.0;
                growth.shoot *= policy.statModifier.shoot || 1.0;
            }

            // Round to 1 decimal
            growth.pass = Math.round(growth.pass * 10) / 10;
            growth.dribble = Math.round(growth.dribble * 10) / 10;
            growth.shoot = Math.round(growth.shoot * 10) / 10;
        } else {
            // Normal training calculation with full modifiers
            let g = {
                pass: menu.effect.pass * personalityMod,
                dribble: menu.effect.dribble * personalityMod,
                shoot: menu.effect.shoot * personalityMod
            };

            // Apply policy modifier
            if (policy.focusLowest) {
                let lowestStat = 'pass';
                let lowestValue = simStats.pass;
                if (simStats.dribble < lowestValue) {
                    lowestStat = 'dribble';
                    lowestValue = simStats.dribble;
                }
                if (simStats.shoot < lowestValue) {
                    lowestStat = 'shoot';
                }
                g[lowestStat] *= policy.multiplier || 1.0;
            } else if (policy.statModifier) {
                g.pass *= policy.statModifier.pass || 1.0;
                g.dribble *= policy.statModifier.dribble || 1.0;
                g.shoot *= policy.statModifier.shoot || 1.0;
            }

            growth = {
                pass: Math.round(g.pass * 10) / 10,
                dribble: Math.round(g.dribble * 10) / 10,
                shoot: Math.round(g.shoot * 10) / 10
            };
        }

        // Add to simulated weekly training (for next day's total training calculation)
        simWeeklyTraining.push({ pass: growth.pass, dribble: growth.dribble, shoot: growth.shoot });

        // Update simulated stats for next day's lowest stat calculation
        simStats.pass += growth.pass;
        simStats.dribble += growth.dribble;
        simStats.shoot += growth.shoot;

        // Accumulate total growth
        totalGrowth.pass += growth.pass;
        totalGrowth.dribble += growth.dribble;
        totalGrowth.shoot += growth.shoot;
    }

    // Round results
    totalGrowth.pass = Math.round(totalGrowth.pass * 10) / 10;
    totalGrowth.dribble = Math.round(totalGrowth.dribble * 10) / 10;
    totalGrowth.shoot = Math.round(totalGrowth.shoot * 10) / 10;

    return totalGrowth;
}

// Helper function to simulate growth with captain modifiers
// P44: training.jsと同様にgrowthMultiplierとboycottEffectを正しく使用
function simulateGrowth(baseEffect) {
    let growth = deepClone(baseEffect);

    // Apply personality modifier
    const personality = CONFIG.CAPTAIN.PERSONALITY[gameState.captain.personality];
    if (personality) {
        let personalityMod = personality.growthMultiplier || 1.0;

        // Check boycott effect
        if (personality.boycottWeek && gameState.currentWeek >= personality.boycottWeek) {
            personalityMod = personality.boycottEffect || 0;
        }

        growth.pass *= personalityMod;
        growth.dribble *= personalityMod;
        growth.shoot *= personalityMod;
    }

    // Round to 1 decimal
    growth.pass = Math.round(growth.pass * 10) / 10;
    growth.dribble = Math.round(growth.dribble * 10) / 10;
    growth.shoot = Math.round(growth.shoot * 10) / 10;

    return growth;
}

// ============================================
// Position Abilities System (PowerPro Style)
// ============================================

// Get all weaknesses across all categories
export function getAllWeaknesses() {
    const weaknesses = [];
    const categories = CONFIG.ABILITIES.categories;

    for (const [categoryKey, category] of Object.entries(categories)) {
        for (const weakness of category.weaknesses) {
            weaknesses.push({
                ...weakness,
                category: categoryKey,
                categoryName: category.name
            });
        }
    }
    return weaknesses;
}

// Get all strengths across all categories
export function getAllStrengths() {
    const strengths = [];
    const categories = CONFIG.ABILITIES.categories;

    for (const [categoryKey, category] of Object.entries(categories)) {
        for (const strength of category.strengths) {
            strengths.push({
                ...strength,
                category: categoryKey,
                categoryName: category.name
            });
        }
    }
    return strengths;
}

// Get remaining (not overcome) weaknesses
export function getRemainingWeaknesses() {
    const all = getAllWeaknesses();
    return all.filter(w => !gameState.abilities.overcomeWeaknesses.includes(w.id));
}

// Get acquired strengths
export function getAcquiredStrengths() {
    const all = getAllStrengths();
    return all.filter(s => gameState.abilities.acquiredStrengths.includes(s.id));
}

// Get remaining (not acquired) strengths
export function getRemainingStrengths() {
    const all = getAllStrengths();
    return all.filter(s => !gameState.abilities.acquiredStrengths.includes(s.id));
}

// Get misconception for a weakness (for display when overcome)
export function getMisconceptionForWeakness(weaknessId) {
    const categories = CONFIG.ABILITIES.categories;

    for (const [categoryKey, category] of Object.entries(categories)) {
        // Find the weakness index in this category
        const weaknessIndex = category.weaknesses.findIndex(w => w.id === weaknessId);
        if (weaknessIndex >= 0 && category.misconceptions[weaknessIndex]) {
            return category.misconceptions[weaknessIndex];
        }
    }
    return null;
}

// P64: Check if all weaknesses in a category are overcome (for misconception correction)
// Returns: { categoryKey, categoryName, misconceptions } or null
function checkCategoryCompletion(weaknessId) {
    const categories = CONFIG.ABILITIES.categories;

    for (const [categoryKey, category] of Object.entries(categories)) {
        // Find if this weakness belongs to this category
        const belongsToCategory = category.weaknesses.some(w => w.id === weaknessId);
        if (!belongsToCategory) continue;

        // Already corrected?
        if (gameState.abilities.correctedCategories.includes(categoryKey)) {
            return null;
        }

        // Check if ALL weaknesses in this category are overcome
        const allWeaknessIds = category.weaknesses.map(w => w.id);
        const allOvercome = allWeaknessIds.every(id =>
            gameState.abilities.overcomeWeaknesses.includes(id)
        );

        if (allOvercome) {
            // Mark category as corrected
            gameState.abilities.correctedCategories.push(categoryKey);

            return {
                categoryKey: categoryKey,
                categoryName: category.name,
                misconceptions: category.misconceptions
            };
        }
    }

    return null;
}

// Process ability changes after training
// Returns: { overcameWeakness: object|null, acquiredStrength: object|null }
export function processAbilityProgress(menuName) {
    const result = {
        overcameWeakness: null,
        acquiredStrength: null,
        correctedMisconceptions: null  // P64: カテゴリ完了時に一括で勘違い改善
    };

    // Ensure abilities structure exists
    if (!gameState.abilities) {
        gameState.abilities = {
            trainingProgress: { judgment: 0, movement: 0, shooting: 0, general: 0 },
            overcomeWeaknesses: [],
            acquiredStrengths: [],
            correctedCategories: [],
            lastChange: null
        };
    }
    // Ensure correctedCategories exists (for save compatibility)
    if (!gameState.abilities.correctedCategories) {
        gameState.abilities.correctedCategories = [];
    }

    // Get training mapping
    const mapping = CONFIG.ABILITIES.trainingMapping[menuName];
    if (!mapping) return result;

    const practicePerChange = CONFIG.ABILITIES.progressConfig.practicePerChange;

    // P66: Randomize order for 総合練習 to ensure fair distribution
    // Previously: judgment→movement→shooting→general (fixed order)
    // This caused back weaknesses (shooting/general) to be processed last
    let processingOrder = [...mapping];
    if (menuName === '総合練習' && processingOrder.length > 1) {
        // Fisher-Yates shuffle
        for (let i = processingOrder.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [processingOrder[i], processingOrder[j]] = [processingOrder[j], processingOrder[i]];
        }
    }

    // P67: Filter out types that have no remaining work (all weaknesses overcome, all strengths acquired)
    // This ensures training progress isn't wasted on completed types
    const typesWithWork = processingOrder.filter(type => {
        // Check if there are remaining weaknesses of this type
        const hasRemainingWeaknesses = getRemainingWeaknesses().some(w => w.type === type);
        if (hasRemainingWeaknesses) return true;

        // Check if there are remaining strengths for categories related to this type
        const hasRemainingStrengths = Object.values(CONFIG.ABILITIES.categories).some(cat => {
            const hasTypeWeakness = cat.weaknesses.some(w => w.type === type);
            const hasUnacquiredStrength = cat.strengths.some(s =>
                !gameState.abilities.acquiredStrengths.includes(s.id)
            );
            return hasTypeWeakness && hasUnacquiredStrength;
        });

        return hasRemainingStrengths;
    });

    // Use filtered types if any remain, otherwise use original order (for edge cases)
    const effectiveOrder = typesWithWork.length > 0 ? typesWithWork : processingOrder;

    // Increment relevant counters
    for (const type of effectiveOrder) {
        gameState.abilities.trainingProgress[type]++;

        // Check if a change should occur
        if (gameState.abilities.trainingProgress[type] >= practicePerChange) {
            // Reset counter
            gameState.abilities.trainingProgress[type] = 0;

            // Try to overcome a weakness of this type first
            const remainingWeaknesses = getRemainingWeaknesses().filter(w => w.type === type);

            if (remainingWeaknesses.length > 0) {
                // Overcome a random weakness of this type
                const weakness = remainingWeaknesses[Math.floor(Math.random() * remainingWeaknesses.length)];
                gameState.abilities.overcomeWeaknesses.push(weakness.id);

                // Get misconception for notification
                const misconception = getMisconceptionForWeakness(weakness.id);

                result.overcameWeakness = {
                    ...weakness,
                    misconception: misconception
                };

                gameState.abilities.lastChange = {
                    type: 'weakness_overcome',
                    data: result.overcameWeakness
                };

                // P64: カテゴリ完了時に勘違いを一括改善
                const categoryCompleted = checkCategoryCompletion(weakness.id);
                if (categoryCompleted) {
                    result.correctedMisconceptions = categoryCompleted;
                    // lastChangeを更新（複数の変化がある場合は勘違い改善を優先表示）
                    gameState.abilities.lastChange = {
                        type: 'misconceptions_corrected',
                        data: categoryCompleted
                    };
                }
            } else {
                // No more weaknesses of this type, try to acquire a strength
                const categoryWithStrength = Object.entries(CONFIG.ABILITIES.categories).find(([key, cat]) => {
                    return cat.weaknesses.some(w => w.type === type) &&
                           cat.strengths.some(s => !gameState.abilities.acquiredStrengths.includes(s.id));
                });

                if (categoryWithStrength) {
                    const [catKey, category] = categoryWithStrength;
                    const availableStrengths = category.strengths.filter(
                        s => !gameState.abilities.acquiredStrengths.includes(s.id)
                    );

                    if (availableStrengths.length > 0) {
                        const strength = availableStrengths[0];
                        gameState.abilities.acquiredStrengths.push(strength.id);

                        result.acquiredStrength = {
                            ...strength,
                            category: catKey,
                            categoryName: category.name
                        };

                        gameState.abilities.lastChange = {
                            type: 'strength_acquired',
                            data: result.acquiredStrength
                        };
                    }
                }
            }

            // Only one change per training
            if (result.overcameWeakness || result.acquiredStrength) {
                break;
            }
        }
    }

    return result;
}

// Get ability status summary for UI
export function getAbilityStatus() {
    const allWeaknesses = getAllWeaknesses();
    const allStrengths = getAllStrengths();

    return {
        totalWeaknesses: allWeaknesses.length,
        overcomeWeaknesses: gameState.abilities.overcomeWeaknesses.length,
        remainingWeaknesses: allWeaknesses.length - gameState.abilities.overcomeWeaknesses.length,
        totalStrengths: allStrengths.length,
        acquiredStrengths: gameState.abilities.acquiredStrengths.length,
        remainingStrengths: allStrengths.length - gameState.abilities.acquiredStrengths.length,
        progress: gameState.abilities.trainingProgress
    };
}

// Get abilities by category for detailed display
export function getAbilitiesByCategory() {
    const categories = CONFIG.ABILITIES.categories;
    const result = {};

    // Ensure correctedCategories exists
    if (!gameState.abilities.correctedCategories) {
        gameState.abilities.correctedCategories = [];
    }

    // ポジション文字列からインデックスへの変換マップ
    const positionToIndex = { 'LW': 0, 'RW': 1, 'CB': 2, 'LB': 3, 'RB': 4, 'P': 5, 'PV': 5 };

    for (const [categoryKey, category] of Object.entries(categories)) {
        // P64: Check if this category's misconceptions are corrected
        const misconceptionsCorrected = gameState.abilities.correctedCategories.includes(categoryKey);

        // P65: Check if any position in this category is an Ace or has Gear Second
        const aces = gameState.team.aces || [];
        const gearSecond = gameState.team.gearSecond || [];
        // ポジション文字列をインデックスに変換して比較
        const categoryIndices = category.positions.map(pos => positionToIndex[pos]);
        const hasAce = categoryIndices.some(idx => aces.includes(idx));
        const hasGearSecond = categoryIndices.some(idx => gearSecond.includes(idx));

        result[categoryKey] = {
            name: category.name,
            positions: category.positions,
            role: category.role || '',
            weaknesses: category.weaknesses.map(w => ({
                ...w,
                overcome: gameState.abilities.overcomeWeaknesses.includes(w.id)
            })),
            // P65: Strengths only active when Ace awakened
            strengths: category.strengths.map(s => ({
                ...s,
                acquired: gameState.abilities.acquiredStrengths.includes(s.id),
                active: gameState.abilities.acquiredStrengths.includes(s.id) && hasAce,
                gearSecond: hasGearSecond
            })),
            // P64: Add corrected status to misconceptions
            misconceptions: (category.misconceptions || []).map(m => ({
                ...m,
                corrected: misconceptionsCorrected
            })),
            allWeaknessesOvercome: misconceptionsCorrected,
            // P65: Category-level ace status
            hasAce: hasAce,
            hasGearSecond: hasGearSecond
        };
    }

    return result;
}

// P70: アクション履歴を記録（最新5件を保持）
export function recordAction(actionType, details) {
    const timestamp = new Date().toISOString();
    const action = {
        timestamp,
        week: gameState.currentWeek,
        day: gameState.currentDay,
        round: gameState.tournament.currentRound,
        type: actionType,
        details: details
    };

    gameState.actionHistory.push(action);

    // 最新5件のみ保持
    if (gameState.actionHistory.length > 5) {
        gameState.actionHistory.shift();
    }
}

// P70: アクション履歴をテキスト形式で取得
export function getActionHistoryText() {
    if (gameState.actionHistory.length === 0) {
        return '履歴なし';
    }

    const lines = gameState.actionHistory.map((action, index) => {
        const dayNames = ['', '月曜', '火曜', '水曜', '木曜', '金曜', '土曜', '日曜'];
        const dayName = dayNames[action.day] || `${action.day}日目`;
        const roundName = getRoundNameForHistory(action.round);

        let line = `${index + 1}. [Week ${action.week} ${dayName}] `;

        switch (action.type) {
            case 'training':
                line += `練習実行: ${action.details.menu}`;
                if (action.details.stats) {
                    line += ` → P:${action.details.stats.pass} D:${action.details.stats.dribble} S:${action.details.stats.shoot}`;
                }
                break;
            case 'match_start':
                line += `試合開始 vs ${action.details.opponent} (${roundName})`;
                break;
            case 'match_tactic':
                line += `作戦設定: ${action.details.tactics}`;
                break;
            case 'match_action':
                line += `試合中: ${action.details.action} - ${action.details.result}`;
                break;
            case 'match_score':
                line += `スコア: ${action.details.playerScore}-${action.details.opponentScore}`;
                break;
            case 'match_end':
                line += `試合終了: ${action.details.result} (${action.details.playerScore}-${action.details.opponentScore})`;
                break;
            case 'screen_change':
                line += `画面遷移: ${action.details.from} → ${action.details.to}`;
                break;
            case 'ace_awakening':
                line += `エース覚醒: ${action.details.position}`;
                break;
            case 'ability_change':
                line += `能力変化: ${action.details.change}`;
                break;
            default:
                line += `${action.type}: ${JSON.stringify(action.details)}`;
        }

        return line;
    });

    return lines.join('\n');
}

// P70: 試合中の詳細状態を取得
export function getMatchStateText() {
    if (!gameState.currentMatch) {
        return '試合中ではありません';
    }

    const match = gameState.currentMatch;
    const roundName = getRoundNameForHistory(gameState.tournament.currentRound);

    let text = `=== 試合状況 ===\n`;
    text += `対戦相手: ${match.opponent.name} (${match.opponent.region})\n`;
    text += `ラウンド: ${roundName}\n`;
    text += `スコア: ${match.playerScore || 0}-${match.opponentScore || 0}\n`;
    text += `残り死に戻り回数: ${match.attemptsLeft || '?'}\n`;
    text += `\n=== 自チーム能力 ===\n`;
    text += `パス: ${gameState.team.stats.pass}\n`;
    text += `ドリブル: ${gameState.team.stats.dribble}\n`;
    text += `シュート: ${gameState.team.stats.shoot}\n`;
    text += `\n=== 相手チーム能力 ===\n`;
    text += `パス: ${match.opponent.stats?.pass || '?'}\n`;
    text += `ドリブル: ${match.opponent.stats?.dribble || '?'}\n`;
    text += `シュート: ${match.opponent.stats?.shoot || '?'}\n`;

    return text;
}

// Helper function for round name
function getRoundNameForHistory(round) {
    const names = {
        1: "1回戦",
        2: "2回戦",
        3: "3回戦",
        4: "準々決勝",
        5: "準決勝",
        6: "決勝"
    };
    return names[round] || `Round ${round}`;
}

// Export for debugging in browser console
if (CONFIG.DEBUG.ENABLED && typeof window !== 'undefined') {
    window.gameState = gameState;
    window.saveGame = saveGame;
    window.loadGame = loadGame;
    window.getAbilityStatus = getAbilityStatus;
    window.getAbilitiesByCategory = getAbilitiesByCategory;
}
