// gameState.js - Game State Management

import { CONFIG } from './config.js';
import { randomFloat, randomChoice, saveToStorage, loadFromStorage, removeFromStorage, deepClone } from './utils.js';

// Game state object
export const gameState = {
    // Current game status
    currentWeek: 1,
    currentDay: 1,

    // Team stats
    team: {
        name: CONFIG.PLAYER_TEAM.name,
        stats: {
            pass: 5,
            dribble: 5,
            shoot: 5
        },
        restBonus: false,
        restPenaltyPending: false,
        aces: [],
        gearSecond: [], // Players who awakened to Gear Second (2.0x multiplier)
        weeklyTraining: [] // Track training this week for total training calculation
    },

    // Captain system
    captain: {
        personality: "熱血",
        policy: "論理的"
    },

    // Tournament data
    tournament: {
        bracket: [],
        currentRound: 1,
        playerTeamId: null,
        results: []
    },

    // Current match data (temporary)
    currentMatch: null,

    // Game completed flag
    gameCompleted: false,
    championshipWon: false
};

// Initialize new game with random captain and stats
export function initializeNewGame() {
    // Random captain personality
    const personalities = Object.keys(CONFIG.CAPTAIN.PERSONALITY);
    gameState.captain.personality = randomChoice(personalities);

    // Random captain policy
    const policies = Object.keys(CONFIG.CAPTAIN.POLICY);
    gameState.captain.policy = randomChoice(policies);

    // Random initial stats
    gameState.team.stats.pass = randomFloat(CONFIG.INITIAL.MIN, CONFIG.INITIAL.MAX, 1);
    gameState.team.stats.dribble = randomFloat(CONFIG.INITIAL.MIN, CONFIG.INITIAL.MAX, 1);
    gameState.team.stats.shoot = randomFloat(CONFIG.INITIAL.MIN, CONFIG.INITIAL.MAX, 1);

    // Reset other values
    gameState.currentWeek = 1;
    gameState.currentDay = 1;
    gameState.team.restBonus = false;
    gameState.team.restPenaltyPending = false;
    gameState.team.aces = [];
    gameState.team.gearSecond = [];
    gameState.team.weeklyTraining = [];
    gameState.tournament.currentRound = 1;
    gameState.tournament.results = [];
    gameState.currentMatch = null;
    gameState.gameCompleted = false;
    gameState.championshipWon = false;

    // Tournament bracket will be generated by tournament.js

    return gameState;
}

// Save game to localStorage
export function saveGame() {
    const success = saveToStorage(CONFIG.GAME.STORAGE_KEY, gameState);
    return success;
}

// Load game from localStorage
export function loadGame() {
    const data = loadFromStorage(CONFIG.GAME.STORAGE_KEY);
    if (data && validateGameState(data)) {
        Object.assign(gameState, data);
        return true;
    }
    return false;
}

// Check if save exists
export function hasSaveData() {
    return loadFromStorage(CONFIG.GAME.STORAGE_KEY) !== null;
}

// Reset game (clear localStorage)
export function resetGame() {
    removeFromStorage(CONFIG.GAME.STORAGE_KEY);
    initializeNewGame();
}

// Validate game state structure
function validateGameState(data) {
    try {
        // Check required fields
        if (!data.currentWeek || !data.currentDay) return false;
        if (!data.team || !data.team.stats) return false;
        if (!data.team.stats.pass || !data.team.stats.dribble || !data.team.stats.shoot) return false;
        if (!data.captain || !data.captain.personality || !data.captain.policy) return false;
        if (!data.tournament) return false;

        // Check valid ranges
        if (data.currentWeek < 1 || data.currentWeek > CONFIG.GAME.TOTAL_WEEKS) return false;
        if (data.currentDay < 1 || data.currentDay > 7) return false;

        return true;
    } catch (e) {
        console.error('Game state validation failed:', e);
        return false;
    }
}

// Advance to next day
export function advanceDay() {
    // Apply rest penalty if pending
    if (gameState.team.restPenaltyPending) {
        const penalty = CONFIG.TRAINING["休養"].penalty.all;
        gameState.team.stats.pass = Math.max(1, gameState.team.stats.pass - penalty);
        gameState.team.stats.dribble = Math.max(1, gameState.team.stats.dribble - penalty);
        gameState.team.stats.shoot = Math.max(1, gameState.team.stats.shoot - penalty);
        gameState.team.restPenaltyPending = false;
    }

    gameState.currentDay++;

    // Check if week ended
    if (gameState.currentDay > 7) {
        advanceWeek();
    }

    // Auto-save if enabled
    if (CONFIG.GAME.AUTO_SAVE) {
        saveGame();
    }
}

// Advance to next week
function advanceWeek() {
    gameState.currentWeek++;
    gameState.currentDay = 1;

    // Clear rest bonus at start of new week
    gameState.team.restBonus = false;

    // Clear weekly training tracking
    gameState.team.weeklyTraining = [];

    // Check if game completed
    if (gameState.currentWeek > CONFIG.GAME.TOTAL_WEEKS) {
        gameState.gameCompleted = true;
    }
}

// Get current day info
export function getCurrentDayInfo() {
    return CONFIG.WEEK_SCHEDULE[gameState.currentDay];
}

// Calculate total training effect based on weekly training
function calculateTotalTrainingEffect() {
    // Find the highest single training value across all weekly training
    let maxValue = 0;

    gameState.team.weeklyTraining.forEach(training => {
        const values = Object.values(training);
        const max = Math.max(...values);
        if (max > maxValue) {
            maxValue = max;
        }
    });

    // If no training this week, use default base value
    if (maxValue === 0) {
        maxValue = 1.2; // Default to match shoot training
    }

    // Divide equally among 3 stats
    const baseValue = maxValue / 3;
    const equalValue = Math.floor(baseValue * 10) / 10; // Floor to 1 decimal place

    // Calculate remainder (keep precision for proper allocation)
    const totalEqual = equalValue * 3;
    const remainder = Math.round((maxValue - totalEqual) * 10) / 10;

    // Allocate remainder based on captain policy
    const policy = CONFIG.CAPTAIN.POLICY[gameState.captain.policy];
    let effect = {
        pass: equalValue,
        dribble: equalValue,
        shoot: equalValue
    };

    // Allocate ALL remainder to favored stat (no splitting)
    if (remainder > 0) {
        if (policy.focusLowest) {
            // Allocate to lowest stat
            const stats = gameState.team.stats;
            const lowestStat = Object.keys(stats).reduce((a, b) =>
                stats[a] < stats[b] ? a : b
            );
            effect[lowestStat] += remainder;
        } else if (policy.statModifier) {
            // Allocate to stat with highest modifier
            const modifiers = policy.statModifier;
            const favoredStat = Object.keys(modifiers).reduce((a, b) =>
                modifiers[a] > modifiers[b] ? a : b
            );
            effect[favoredStat] += remainder;
        } else {
            // Default: allocate to pass
            effect.pass += remainder;
        }
    }

    return effect;
}

// Apply training to team stats
export function applyTraining(menuName) {
    const menu = CONFIG.TRAINING[menuName];
    if (!menu) return false;

    // Check if training is available on current day
    const currentDayName = getCurrentDayInfo().day;
    if (!menu.available.includes(currentDayName)) {
        return false;
    }

    // Check for boycott
    if (isBoycottActive()) {
        return false;
    }

    // Handle rest bonus
    if (menuName === "休養") {
        gameState.team.restBonus = true;
        return true;
    }

    // Calculate growth with captain modifiers
    let baseEffect = menu.effect;

    // For total training, use dynamic calculation
    if (menuName === "総合練習") {
        baseEffect = calculateTotalTrainingEffect();
    }

    const growth = calculateTrainingGrowth(baseEffect);

    // Record this training for weekly tracking (before total training)
    if (menuName !== "総合練習") {
        gameState.team.weeklyTraining.push(deepClone(growth));
    }

    // Apply growth to stats
    gameState.team.stats.pass += growth.pass;
    gameState.team.stats.dribble += growth.dribble;
    gameState.team.stats.shoot += growth.shoot;

    // Round if needed (keep float for total training)
    if (!menu.allowFloat) {
        gameState.team.stats.pass = Math.round(gameState.team.stats.pass * 10) / 10;
        gameState.team.stats.dribble = Math.round(gameState.team.stats.dribble * 10) / 10;
        gameState.team.stats.shoot = Math.round(gameState.team.stats.shoot * 10) / 10;
    }

    return true;
}

// Calculate training growth with captain modifiers
function calculateTrainingGrowth(baseEffect) {
    let growth = deepClone(baseEffect);

    // Apply personality modifier
    const personalityMod = getPersonalityModifier();
    growth.pass *= personalityMod;
    growth.dribble *= personalityMod;
    growth.shoot *= personalityMod;

    // Apply policy modifier
    const policy = CONFIG.CAPTAIN.POLICY[gameState.captain.policy];

    if (policy.focusLowest) {
        // Find lowest stat
        const stats = gameState.team.stats;
        const lowestStat = Object.keys(stats).reduce((a, b) =>
            stats[a] < stats[b] ? a : b
        );
        growth[lowestStat] *= policy.multiplier;
    } else if (policy.statModifier) {
        // Apply stat-specific modifiers
        growth.pass *= policy.statModifier.pass;
        growth.dribble *= policy.statModifier.dribble;
        growth.shoot *= policy.statModifier.shoot;
    }

    return growth;
}

// Get personality modifier (check for boycott)
function getPersonalityModifier() {
    const personality = CONFIG.CAPTAIN.PERSONALITY[gameState.captain.personality];

    // Check boycott condition
    if (personality.boycottWeek && gameState.currentWeek >= personality.boycottWeek) {
        return personality.boycottEffect;
    }

    return personality.growthMultiplier;
}

// Check if boycott is active
export function isBoycottActive() {
    const personality = CONFIG.CAPTAIN.PERSONALITY[gameState.captain.personality];
    return personality.boycottWeek && gameState.currentWeek >= personality.boycottWeek;
}

// Add ace after winning a match (excluding GK)
// If all field players are already aces, awaken to Gear Second
// Returns object with awakening info: { type: 'ace' | 'gearSecond', positionIndex: number, positionName: string }
export function addAce() {
    // GK is at position 6, so only select from positions 0-5
    const fieldPlayerPositions = [0, 1, 2, 3, 4, 5];

    // Check if all field players are already aces
    const allAces = fieldPlayerPositions.every(pos => gameState.team.aces.includes(pos));

    if (allAces) {
        // All are aces, now awaken to Gear Second
        const availableForGearSecond = fieldPlayerPositions.filter(pos =>
            !gameState.team.gearSecond.includes(pos)
        );

        if (availableForGearSecond.length > 0) {
            const randomIndex = Math.floor(Math.random() * availableForGearSecond.length);
            const newGearSecondIndex = availableForGearSecond[randomIndex];
            gameState.team.gearSecond.push(newGearSecondIndex);

            // Get position name
            const positionKeys = ['LW', 'RW', 'CB', 'LB', 'RB', 'P'];
            const positionKey = positionKeys[newGearSecondIndex];
            const positionName = CONFIG.POSITIONS[positionKey].name;

            return {
                type: 'gearSecond',
                positionIndex: newGearSecondIndex,
                positionKey: positionKey,
                positionName: positionName
            };
        }
    } else {
        // Not all are aces yet, make someone an ace
        const availablePositions = fieldPlayerPositions.filter(pos =>
            !gameState.team.aces.includes(pos)
        );

        if (availablePositions.length > 0) {
            const randomIndex = Math.floor(Math.random() * availablePositions.length);
            const newAceIndex = availablePositions[randomIndex];
            gameState.team.aces.push(newAceIndex);

            // Get position name
            const positionKeys = ['LW', 'RW', 'CB', 'LB', 'RB', 'P'];
            const positionKey = positionKeys[newAceIndex];
            const positionName = CONFIG.POSITIONS[positionKey].name;

            return {
                type: 'ace',
                positionIndex: newAceIndex,
                positionKey: positionKey,
                positionName: positionName
            };
        }
    }

    return null; // No awakening (all already Gear Second)
}

// Get team stats with rest bonus applied
export function getEffectiveStats() {
    const stats = deepClone(gameState.team.stats);

    if (gameState.team.restBonus) {
        const bonus = CONFIG.TRAINING["休養"].bonus.all;
        stats.pass += bonus;
        stats.dribble += bonus;
        stats.shoot += bonus;
    }

    return stats;
}

// Clear rest bonus (after match)
export function clearRestBonus() {
    gameState.team.restBonus = false;
}

// Set current match
export function setCurrentMatch(opponent) {
    gameState.currentMatch = {
        opponent: opponent,
        playerScore: 0,
        opponentScore: 0,
        isPlaying: false,
        result: null,
        attemptsRemaining: CONFIG.GAME.MAX_ATTEMPTS,
        savedTactics: [],
        failedTacticIndex: null
    };
}

// Reset failed tactic index (call when starting fresh tactics)
export function resetFailedTacticIndex() {
    if (gameState.currentMatch) {
        gameState.currentMatch.failedTacticIndex = null;
    }
}

// Clear current match
export function clearCurrentMatch() {
    gameState.currentMatch = null;
}

// Record match result
// Returns awakening info if won: { type: 'ace' | 'gearSecond', positionName: string } or null
export function recordMatchResult(won, playerScore, opponentScore) {
    const result = {
        week: gameState.currentWeek,
        round: gameState.tournament.currentRound,
        opponent: gameState.currentMatch.opponent.name,
        won: won,
        playerScore: playerScore,
        opponentScore: opponentScore
    };

    gameState.tournament.results.push(result);

    let awakeningInfo = null;

    // Add ace if won
    if (won) {
        awakeningInfo = addAce();
        gameState.tournament.currentRound++;

        // Check if championship won
        if (gameState.tournament.currentRound > 6) {
            gameState.championshipWon = true;
            gameState.gameCompleted = true;
        }
    } else {
        gameState.gameCompleted = true;
    }

    // Clear rest bonus after match and set penalty flag
    if (gameState.team.restBonus) {
        gameState.team.restPenaltyPending = true;
    }
    clearRestBonus();

    // Clear current match
    clearCurrentMatch();

    return awakeningInfo;
}

// Get game state snapshot (for debugging)
export function getStateSnapshot() {
    return deepClone(gameState);
}

// Export for debugging in browser console
if (CONFIG.DEBUG.ENABLED) {
    window.gameState = gameState;
    window.saveGame = saveGame;
    window.loadGame = loadGame;
}
